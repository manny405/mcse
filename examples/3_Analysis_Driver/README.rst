Before beginning, please make sure you have have navigated to the ``examples/3_Analysis_Driver`` folder. This folder contains all the files necessary for the following examples. All examples discussed here are also included as a script in the ``example.py`` file. .. contents::   :local:################Analysis Drivers################The ``Driver`` class defines the core API for complex analysis of molecular crystals in the ``mcse`` library. The features and standardization of this API lends itself to the analysis of many hundreds or thousands of crystal structures. Additionally, parallelization of the analysis can be easily provided through ``mcse.libmpi``. In this document, all of the currently available molecular crystal analysis ``Drivers`` will be presented.  Then, parallelization examples will be given using ``libmpi``. Please note that for now these are only the ``Drivers`` that have been included in the pre-release and also may have some features removed compared to the full library. There are many more analysis capabilities that will be added upon the full release of the ``mcse`` package. ^^^^^^^^^^^^^FindMolecules^^^^^^^^^^^^^ ``FindMolecules`` was initially introduced in the *2_Standardize* example. More information about the general functions of ``FindMolecules`` can be found there. To summarize briefly, ``FindMolecules`` will identify the molecules in the crystal structure, repair covalent bonds across periodic boundary conditions, and identify the unique molecules that make up the crystal structure. ``FindMolecules`` will be used to discuss the standardized ``Driver`` API. In addition, details about the ``FindMolecule`` settings and options will be discussed. The first step for any ``Driver`` is to initialize all of the user defined settings. In this example, three options within ``FindMolecules`` will be discussed. These are ``residues``, ``mult``, and ``conformation``. * ``residues``: Integer number of unique molecules the user would like to find. If an integer value besides 0 is supplied, then the mult parameter will be varied to try to achieve this exact number of unique residues in the system. This is useful if the algorithm is having difficulty finding exactly one unique residue when it's known that the input structure is homomolecular.* ``mult``: Multiplicative factor multiplied by the covalent bond radii of each atom in order to find molecules. A default value of ``1.05`` is set for molecular crystals. This value will work well in most cases.* ``conformation``: This argument is used to control how unqiue molecules will be identified. If ``True``, identifying duplicate molecules will be performed by comparing the cartesian coordinates of each molecule through a root-mean-square-difference (RMSD) algorithm included in ``mcse``. The default tolerance is 0.1, which may be changed using the ``rmsd_tol`` argument. The default value will work well in most cases. If ``False``, identifying molecules will be performed using a graph based representation of the molecules. This is to say that molecules will be duplicates if they exhibit the same covalent bonding.         The default settings for ``FindMolecules`` will be initialized in this example... code-block:: Python    >>> from mcse.crystals import FindMolecules    >>> fm = FindMolecules(residues=0, mult=1.05, conformation=True)    The next step for any analysis ``Driver`` is to call the ``Driver.calc`` method. The input to this can be either a single structure or a dictionary of structures. The ``Driver`` will automatically iterate over each structure in the dictionary if one is provided. Continuing from the previous commands:.. code-block:: Python    >>> from mcse.io import read,write    >>> struct = read("PUBMUU02.cif")    >>> fm.calc(struct)    >>> fm.molecules    {'PUBMUU02_Molecule_0': PUBMUU02_Molecule_0: Molecule {'C': 6, 'H': 6, 'N': 12, 'O': 12},     'PUBMUU02_Molecule_1': PUBMUU02_Molecule_1: Molecule {'C': 6, 'H': 6, 'N': 12, 'O': 12},     'PUBMUU02_Molecule_2': PUBMUU02_Molecule_2: Molecule {'C': 6, 'H': 6, 'N': 12, 'O': 12},     'PUBMUU02_Molecule_3': PUBMUU02_Molecule_3: Molecule {'C': 6, 'H': 6, 'N': 12, 'O': 12}}    >>> struct_dict = read("Example_Structures")    >>> fm.calc(struct_dict)However, calculating over the dictionary of structures doesn't produce any usable result other than to check that molecules can be found success for all the structures. In order to save the results, settings ``write=True`` will provide an automated, default method for writing the results. More fine-grained control over how the results are written requires the user to call the ``Driver.write`` method themselves while iterating over the structures. Continuing from the previous commands:.. code-block:: Python        ### Default writing     >>> fm.calc(struct_dict, write=True)    ### User defined writing    >>> for struct_id,struct in struct_dict.items():    ...     fm.calc(struct)    ...     fm.write("Molecules", file_format="xyz", overwrite=True)^^^^^^^^^^^^^PackingFactor^^^^^^^^^^^^^A simple analysis to perform for any crystal structure is the calculation of the packing factor. This is the ratio between the volume enclosed by the unit cell and the volume enclosed by the van der Waals spheres of the molecules in the crystal. This ``Driver`` calculates the packing factor of a crystal using a grid based approach. It splits up the unit cell into a 3D grid then checks whether a grid position is populated by any of the atoms in the crystal. Provided is an example of calculating the packing factor for the example structures. .. code-block:: Python    >>> from mcse.crystals.packing_factor import PackingFactor    >>> pf =  PackingFactor()    >>> struct = read("PUBMUU02.cif")    >>> result = pf.calc(struct)    >>> result    0.744    >>> struct.properties["PackingFactor"]    0.744    In addition to returning the numerical result, the analysis ``Driver`` will also store the result in the properties of the structure. Generally the stored name will match the ``Driver`` name.^^^^^Motif^^^^^Another common analysis method specific for molecular crystal structures of rigid molecules is the identification of the molecular packing motif. Such methods are particularly important for energetic materials and organic semiconductors. Please be aware that in this pre-release of ``mcse``, only identification of sheet motifs and gamma motifs have been included. A more feature-rich version will be made available upon full release. An example of motif calculation using ``mcse`` is given below for TATB and DATB. Both are energetic materials. It's well known that TATB has a sheet motif and is relatively insensitive. DATB has a gamma type motif and is relatively more sensitive than TATB. .. code-block:: Python    >>> from mcse.crystals.motif import Motif    >>> m = Motif()    >>> struct_dict = read("Example_Structures")     >>> m.calc(struct_dict["TATNBZ"])    sheet    >>> m.calc(struct_dict["DATNBZ01A"])    gamma################Pairwise Drivers################``PairwiseDrivers`` are those that take two structures as the input to the ``PairwiseDriver.calc(struct1, struct2)`` method. These ``Drivers`` are typically those that will perform some type of comparison between two structures. If a dictionary of structures is provided to ``PairwiseDriver.calc(struct_dict)`` method, then the calculation between all pairs of structures in the dictionary will be performed. Since this calculation scales exponentially with the number of structures in the dictionary, efficient `parallelization`_ is particularly important. Automatic parallelization is demonstrated in the next section. ^^^^^^^^^^^^^^DuplicateCheck^^^^^^^^^^^^^^The ``DuplicateCheck`` pairwise driver is used to check if two crystal geometries are duplicates. It may also be used to check for duplicates across a dictionary of structures. By default, the duplicate check takes advantage of the Pymatgen ``StructureMatcher`` using settings that work well for molecular crystals. The ``DuplicateCheck`` can be used with any other Python callable that compares two geometries and returns whether or not they are duplicates. An example using  ``DuplicateCheck`` is given below. Demonstrated are the different ways to access information about duplicates stored by the calculation. Most importantly, a unique set of structures can be obtained from ``DuplicateCheck.unique``... code-block:: Python    >>> from mcse.io import read,write    >>> from mcse.crystals import DuplicateCheck    >>> struct_dict = read("DuplicateCheck_Example_Structures")    >>> dc = DuplicateCheck()    >>> dc.calc(struct_dict)    >>> struct_dict["3ddf4a302a"].properties["DuplicateCheck"]    [('fafdb8075b', False),     ('8aeae1272d', True),     ...    >>> dc.duplicate_dict    {'3ddf4a302a': ['3ddf4a302a', '8aeae1272d', '764837dd18'],     'fafdb8075b': ['fafdb8075b', 'c842a3018c'],     '8aeae1272d': ['8aeae1272d', '3ddf4a302a', '764837dd18'],     '6b20645c63': ['6b20645c63', 'a06049b7fb', '5b65124a54'],     'c842a3018c': ['c842a3018c', 'fafdb8075b', '1dcf9d7b48'],     'a06049b7fb': ['a06049b7fb', '6b20645c63', '5b65124a54'],     'f72df8ef20': ['f72df8ef20', '48956f9fc8'],     '87198df5bd': ['87198df5bd', 'fc12b1fda5', '9de0072986'],     '5b65124a54': ['5b65124a54', '6b20645c63', 'a06049b7fb'],     'fc12b1fda5': ['fc12b1fda5', '87198df5bd', '9de0072986'],     '764837dd18': ['764837dd18', '3ddf4a302a', '8aeae1272d'],     '48956f9fc8': ['48956f9fc8', 'f72df8ef20'],     '1dcf9d7b48': ['1dcf9d7b48', 'c842a3018c'],     '9de0072986': ['9de0072986', '87198df5bd', 'fc12b1fda5']}    >>> dc.unique    {'3ddf4a302a': 3ddf4a302a: Crystal {'C': 12, 'H': 10, 'N': 10, 'O': 12},     'fafdb8075b': fafdb8075b: Crystal {'C': 12, 'H': 10, 'N': 10, 'O': 12},     '6b20645c63': 6b20645c63: Crystal {'C': 12, 'H': 10, 'N': 10, 'O': 12},     'f72df8ef20': f72df8ef20: Crystal {'C': 12, 'H': 10, 'N': 10, 'O': 12},     '87198df5bd': 87198df5bd: Crystal {'C': 12, 'H': 10, 'N': 10, 'O': 12},     '1dcf9d7b48': 1dcf9d7b48: Crystal {'C': 12, 'H': 10, 'N': 10, 'O': 12}}^^^^RMSD^^^^A common task for the analysis of molecular crystals is to find the root-mean-square (RMSD) deviation between two geometries. For these periodic systems this task is quite complicated. The algorithm implemented in ``mcse`` is as follows. 1. Given a *target* periodic geometry and a *candidate* periodic geometry2. A cluster of ``nn`` nearest neighbors is exacted from the periodic *target* geometry3. All possible nearest neighbor clusters of size ``nn_search`` are extracted from the *candidate* geometry4. All reasonable candidate clusters, as determined by ``stol`` which is a center-of-mass site tolerance, are compared to the *target* nearest neighbor cluster5. The comparison of *candidate* clusters stops once a cluster is found with a root-mean-square deviation below ``tol``. If no such cluster is found, the *candidate* cluster with the minimum RMSD is chosen.    An example of ``RMSD`` is given below using the ``Pairwise_Example_Structures`` folder. This folder contains a small subset of geometries from the previous `DuplicateCheck`_ example. Within this folder, there are molecular crystals that are known to be duplicates. This result is demonstrated in the example below. Please be patient as the example runs. Due to the complexity of the implemented algorithm it may take around a minute to evaluate this example. .. code-block:: Python    >>> from mcse.io import read,write    >>> from mcse.crystals import RMSD    >>> struct_dict = read("RMSD_Example_Structures")    >>> rmsd = RMSD(nn=12, search_nn=16, verbose=True)    >>> rmsd.calc(struct_dict)    1/10: 3ddf4a302a,fafdb8075b=2.959336    2/10: 3ddf4a302a,8aeae1272d=0.130586    3/10: 3ddf4a302a,6b20645c63=4.281341    4/10: 3ddf4a302a,c842a3018c=3.005641    5/10: fafdb8075b,8aeae1272d=4.207395    6/10: fafdb8075b,6b20645c63=3.557169    7/10: fafdb8075b,c842a3018c=0.283276    8/10: 8aeae1272d,6b20645c63=3.156732    9/10: 8aeae1272d,c842a3018c=3.676263    10/10: 6b20645c63,c842a3018c=2.908700    Demonstrated by the results, geometries that were known to be duplicates have a relatively small RMSD. For periodic molecular crystals, a reasonable cutoff for duplicates by this method is between 0.2-0.4 depending on how the geometries have been obtained or whether the geometries have been relaxed using DFT or a force field. A method for rendering images of the molecular clusters produced by this algorithm is demonstrated in the 4_Visualization examples folder.###############Parallelization############### Parallelization is carried out for both the ``Driver`` and ``PairwiseDriver`` using the ``mcse.libmpi.ParallelCalc`` class. Examples of this parallelization is given for calculating the packing factor and RMSD. Parallelization is accomplished using the message passing interface (MPI) through the Python bindings provided by ``mpi4py``. Parallel calculations using ``mcse`` have been tested to scale efficiently to hundreds of cores for the analysis of tens of thousands or hundreds of thousands of molecular crystals. ^^^^^^^^^^^^^^^^^^^^^^Driver Parallelization^^^^^^^^^^^^^^^^^^^^^^The following lines of code are responsible for parallelizing the packing factor calculation. This code is taken from the ``mpi_examples.py`` file. The packing factor ``Driver`` needs to be provided to ``ParallelCalc`` along with input and output directories for the structure files. For this example, the input directory ``Parallel_Example_Structures`` contains 114 crystals, a sizable calculation for a single laptop. As the packing factor is calculated for each geometry, the results will be saved and stored in the ``Packing_Factor_Calculated`` folder. .. code-block:: Python    from mcse.io import read,write    from mcse.libmpi import ParallelCalc    from mcse.crystals.packing_factor import PackingFactor        pf =  PackingFactor(spacing=0.25)    pc = ParallelCalc(struct_path="Parallel_Example_Structures",                       output_path="Packing_Factor_Calculated",                       driver=pf,                      overwrite=True,                      verbose=False)The parallel calculation can then be executed with the following command line. .. code-block:: bash        $ mpirun -np 4 python mpi_examples.pyOn a test server, running the calculation using 1 core took 68.44 seconds, 2 cores took 34.39  seconds, 4 cores took 18.2 seconds, and 8 cores took 9.25 seconds. Thus the speedup is nearly ideal for this small test case. ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^PairwiseDriver Parallelization^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Parallelization of the ``PairwiseDriver`` is accomplished using the same API as above. The following example demonstrates parallelizing a duplicate check. The code for this example is also available in the ``mpi_examples.py`` file. .. code-block:: Python    from mcse.io import read,write    from mcse.libmpi import ParallelCalc    from mcse.crystals import DuplicateCheck        dc = DuplicateCheck()    pc = ParallelCalc(                  struct_path="Parallel_Example_Structures",                   output_path="Duplicate_Check_Calculated",                   driver=dc,                  overwrite=True,                  verbose=False)    pc.calc()    The parallel calculation can be executed with the following command line... code-block:: bash    $ mpirun -np 4 python mpi_examples    Running the calculation for 114 structures amounts to 6,441 geometry comparisons that need to take place. On a test server, running the calculation using 1 core took 52.40 seconds, using 4 cores took 16.189 seconds, and using 8 cores took  7.8 seconds.#########Molecules#########While there aren't any ``Drivers`` for performing analysis of molecules, there are many useful functions that are available within ``mcse``. The lack of ``Drivers`` is because the implemented analysis methods for molecules isn't sufficiently complex to warrent such a rigorous API. It's more natural to interact with molecules using functions that take only a small number of arguments rather than having to initialize a ``Driver`` class. Some examples of the useful functions implemented in ``mcse`` for analysis of molecules are given below... code-block:: Python    >>> from mcse.io import read,write    >>> mol = read("benzene.xyz")    # Get center of mass of molecule    >>> from mcse import com    >>> com(mol)    array([0., 0., 0.])    >>> from mcse.molecules import get_principal_axes    >>> get_principal_axes(mol)    array([[ 0.69487709,  0.24038447,  0.67776186],           [-0.07722397,  0.96197004, -0.26201163],           [-0.71497013,  0.12972641,  0.68701439]])    >>> from mcse.molecules import align    >>> align(mol)    >>> get_principal_axes(mol)    array([[1., 0., 0.],           [0., 1., 0.],           [0., 0., 1.]])    >>> from mcse.molecules.symmetry import get_symmetry    >>> get_symmetry(mol)    array([[[-1.    ,  0.    ,  0.    ],            [ 0.    , -1.    ,  0.    ],            [ 0.    ,  0.    , -1.    ]],               [[-1.    ,  0.    ,  0.    ],            [ 0.    , -0.809 , -0.5878],            [ 0.    , -0.5878,  0.809 ]],               [[-1.    ,  0.    ,  0.    ],            [ 0.    ,  0.809 ,  0.5878],            [ 0.    ,  0.5878, -0.809 ]],               [[-1.    ,  0.    ,  0.    ],            [ 0.    ,  1.    ,  0.    ],            [ 0.    ,  0.    ,  1.    ]],               [[ 1.    ,  0.    ,  0.    ],            [ 0.    , -1.    ,  0.    ],            [ 0.    ,  0.    , -1.    ]],               [[ 1.    ,  0.    ,  0.    ],            [ 0.    ,  1.    ,  0.    ],            [ 0.    ,  0.    ,  1.    ]]])               